package internal

import "text/template"

// FixToProtoConversionTemplate generates conversion functions from FIX messages to protobuf messages
var FixToProtoConversionTemplate = template.Must(template.New("fix_to_proto_conversion.go").Funcs(templateFuncs).Parse(`// Code generated by generate-pb. DO NOT EDIT.
// This file contains conversion functions from FIX messages to protobuf messages.

package {{extractPackageName .GoPackagePrefix}}

import (
	"strconv"
	
	"github.com/quickfixgo/quickfix"
)

{{range .Messages}}
// {{.Name}}FromFIX converts a FIX {{.Name}} message to protobuf {{.Name}}
func {{.Name}}FromFIX(fixMsg quickfix.Messagable) (*{{.Name}}, error) {
	pbMsg := &{{.Name}}{}
	
	{{range $field := getRequiredFields .MessageDef}}{{if not $field.IsGroup}}
	// Convert required field {{$field.FieldType.Name}} (Tag {{$field.FieldType.Tag}})
	if fieldValue, err := getFixFieldValueFromMessage(fixMsg, {{$field.FieldType.Tag}}); err == nil {
		convertedValue := {{convertFixFieldToProto $field "pbMsg" "fixMsg"}}
		{{setProtoField $field "pbMsg" "convertedValue"}}
	}
	{{end}}{{end}}
	
	{{range $field := getOptionalFields .MessageDef}}{{if not $field.IsGroup}}
	// Convert optional field {{$field.FieldType.Name}} (Tag {{$field.FieldType.Tag}})
	if fieldValue, err := getFixFieldValueFromMessage(fixMsg, {{$field.FieldType.Tag}}); err == nil {
		convertedValue := {{convertFixFieldToProto $field "pbMsg" "fixMsg"}}
		{{setProtoField $field "pbMsg" "convertedValue"}}
	}
	{{end}}{{end}}
	
	{{/* Repeating groups are complex to handle correctly in QuickFIX, skipping for now
	{{range $group := getAllGroups .MessageDef}}
	// Convert repeating group {{$group.FieldType.Name}}
	if {{$group.FieldType.Name}}Group, err := {{getFixGroupValue $group "fixMsg"}}; err == nil {
		for i := 0; i < {{$group.FieldType.Name}}Group.Len(); i++ {
			groupEntry := {{$group.FieldType.Name}}Group.Get(i)
			pbGroupEntry := &{{generateGroupMessageName $group}}{}
			
			{{range $groupField := $group.RequiredFields}}
			if fieldValue, err := getFixFieldValueFromMessage(groupEntry, {{$groupField.FieldType.Tag}}); err == nil {
				convertedValue := {{convertFixFieldToProto $groupField "pbGroupEntry" "groupEntry"}}
				{{setProtoField $groupField "pbGroupEntry" "convertedValue"}}
			}
			{{end}}
			
			{{range $groupField := $group.Fields}}{{$isRequired := false}}{{range $req := $group.RequiredFields}}{{if eq $req.FieldType.Tag $groupField.FieldType.Tag}}{{$isRequired = true}}{{end}}{{end}}{{if not $isRequired}}
			if fieldValue, err := getFixFieldValueFromMessage(groupEntry, {{$groupField.FieldType.Tag}}); err == nil {
				convertedValue := {{convertFixFieldToProto $groupField "pbGroupEntry" "groupEntry"}}
				{{setProtoField $groupField "pbGroupEntry" "convertedValue"}}
			}
			{{end}}{{end}}
			
			pbMsg.{{protoFieldNameToGoFieldName (sanitizeProtoFieldName $group.FieldType.Name)}} = append(pbMsg.{{protoFieldNameToGoFieldName (sanitizeProtoFieldName $group.FieldType.Name)}}, pbGroupEntry)
		}
	}
	{{end}}
	*/}}
	
	{{range $component := getRequiredComponents .MessageDef}}
	// Convert required component {{$component.Name}}
	// Note: Component conversion requires additional implementation based on component structure
	// TODO: Implement component conversion for {{$component.Name}}
	{{end}}
	
	{{range $component := getOptionalComponents .MessageDef}}
	// Convert optional component {{$component.Name}}
	// Note: Component conversion requires additional implementation based on component structure
	// TODO: Implement component conversion for {{$component.Name}}
	{{end}}
	
	return pbMsg, nil
}
{{end}}

// Helper functions for field value conversion

// getFixFieldValueFromMessage extracts a field value from a FIX message by tag
func getFixFieldValueFromMessage(msg quickfix.Messagable, tag int) (string, error) {
	fixMsg := msg.ToMessage()
	if value, err := fixMsg.Body.GetString(quickfix.Tag(tag)); err != nil {
		return "", err
	} else {
		return value, nil
	}
}

{{range getAllEnumDefinitions}}
// Convert{{.Name}}FromFIX converts FIX enum string to protobuf enum
func Convert{{.Name}}FromFIX(fixValue string) {{.ProtoName}} {
	switch fixValue {
	{{$enumProtoName := .ProtoName}}{{range .Values}}case "{{.StringValue}}":
		return {{$enumProtoName}}_{{.GetProtoEnumValueName $enumProtoName}}
	{{end}}default:
		return {{$enumProtoName}}_{{(index .Values 0).GetProtoEnumValueName $enumProtoName}} // Use first enum value as default
	}
}

// Convert{{.Name}}ToFIX converts protobuf enum to FIX enum string
func Convert{{.Name}}ToFIX(protoValue {{.ProtoName}}) string {
	switch protoValue {
	{{$enumProtoName := .ProtoName}}{{range .Values}}case {{$enumProtoName}}_{{.GetProtoEnumValueName $enumProtoName}}:
		return "{{.StringValue}}"
	{{end}}default:
		return ""
	}
}

{{end}}
`))
